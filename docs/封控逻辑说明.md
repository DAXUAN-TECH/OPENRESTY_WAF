# 封控逻辑说明文档

## 一、封控流程概述

### 1.1 整体流程

```
请求进入 → 系统访问白名单检查 → WAF封控检查 → 规则匹配 → 封控决策 → 记录日志 → 返回响应
```

### 1.2 封控检查触发条件

**HTTP/HTTPS 代理**：
- 代理必须关联防护规则（`ip_rule_ids` 不为空）
- 在生成的配置文件中，会添加 `access_by_lua_block` 调用 `require("waf.ip_block").check_multiple(rule_ids)`
- 如果代理没有关联防护规则，**不会执行封控检查**

**TCP/UDP 代理**：
- 代理必须关联防护规则（`ip_rule_ids` 不为空）
- 在生成的配置文件中，会添加 `preread_by_lua_block` 调用 `require("waf.ip_block").check_stream()`

**管理端（waf.conf）**：
- 封控检查被注释掉了（管理端通常不需要封控）
- 只有系统访问白名单检查

### 1.3 封控检查顺序

1. **白名单检查**（优先级最高）
   - 如果 IP 在白名单中，直接允许通过，不执行后续检查

2. **自动封控检查**
   - 检查是否触发自动封控（基于频率、错误率、扫描行为等）

3. **单个 IP 封控**
   - 检查 `waf_block_rules` 表中 `rule_type = 'ip_blacklist'` 且 `rule_value` 匹配单个 IP 的规则

4. **IP 段封控**
   - 检查 `waf_block_rules` 表中 `rule_type = 'ip_blacklist'` 且 `rule_value` 匹配 IP 段的规则（CIDR 格式或 IP 范围）

5. **地域封控**
   - 检查 `waf_block_rules` 表中 `rule_type = 'geo_block'` 的规则（需要 GeoIP2 数据库）

6. **频率封控**
   - 基于访问频率统计，自动判断是否需要封控

### 1.4 封控决策

当检测到封控时：
1. **记录封控日志**：调用 `log_block(client_ip, matched_rule, block_reason)`
2. **记录监控指标**：如果启用了 metrics，记录封控指标
3. **返回 403 错误**：HTTP/HTTPS 代理返回 403 页面，TCP/UDP 代理拒绝连接

## 二、封控日志记录机制

### 2.1 日志记录流程

```
log_block() → log_queue.retry_write() → 首次写入数据库
                                    ↓ 失败
                              添加到重试队列
                                    ↓
                            定时器处理重试队列（每5秒）
                                    ↓
                            重试写入数据库（最多3次）
                                    ↓ 仍然失败
                            写入本地备份文件
```

### 2.2 日志数据结构

封控日志写入 `waf_block_logs` 表，包含以下字段：
- `client_ip`：被封控的客户端 IP
- `rule_id`：匹配的封控规则 ID
- `rule_name`：规则名称
- `block_reason`：封控原因（manual、auto_frequency、auto_error、auto_scan）
- `block_time`：封控发生时间
- `request_path`：触发封控的请求路径
- `user_agent`：User-Agent 信息

### 2.3 重试机制

- **首次写入**：直接尝试写入数据库
- **重试队列**：写入失败时，添加到重试队列
- **定时处理**：`init.lua` 中的定时器每 5 秒处理一次重试队列
- **最大重试次数**：3 次（可配置）
- **本地备份**：超过最大重试次数后，写入本地备份文件 `logs/block_YYYYMMDD.log`

## 三、封控日志为空的可能原因

### 3.1 代理没有关联防护规则

**检查方法**：
```sql
SELECT id, proxy_name, ip_rule_ids 
FROM waf_proxy_configs 
WHERE status = 1;
```

**解决方案**：
- 在代理管理页面，为代理添加防护规则
- 确保 `ip_rule_ids` 字段不为空

### 3.2 没有启用状态的封控规则

**检查方法**：
```sql
SELECT id, rule_name, rule_type, status 
FROM waf_block_rules 
WHERE status = 1 
AND rule_type IN ('ip_blacklist', 'geo_block');
```

**解决方案**：
- 在防护规则页面，创建并启用封控规则
- 确保规则类型为 `ip_blacklist` 或 `geo_block`

### 3.3 规则没有匹配客户端 IP

**检查方法**：
- 查看 Nginx 错误日志，是否有封控相关的日志
- 检查规则的 `rule_value` 是否包含客户端 IP

**解决方案**：
- 创建测试规则，直接封控你的测试 IP
- 或者创建 IP 段规则，包含你的测试 IP

### 3.4 MySQL 连接失败导致日志写入失败

**检查方法**：
- 查看 Nginx 错误日志，是否有 MySQL 连接超时/失败的错误
- 检查本地备份文件：`logs/block_YYYYMMDD.log`

**解决方案**：
- 修复 MySQL 连接问题（网络、防火墙、安全组等）
- 检查本地备份文件，确认是否有封控日志（说明封控已触发，但数据库写入失败）

### 3.5 功能开关被禁用

**检查方法**：
```sql
SELECT feature_key, enable 
FROM waf_feature_switches 
WHERE feature_key IN ('block_enable', 'ip_block', 'auto_block');
```

**解决方案**：
- 确保相关功能开关都是启用状态（`enable = 1`）

## 四、排查步骤

### 4.1 检查代理配置

1. **确认代理已创建且启用**：
   ```sql
   SELECT id, proxy_name, proxy_type, status, ip_rule_ids 
   FROM waf_proxy_configs 
   WHERE status = 1;
   ```

2. **确认代理关联了防护规则**：
   - `ip_rule_ids` 字段不为空
   - 规则 ID 存在于 `waf_block_rules` 表中

### 4.2 检查防护规则

1. **确认有启用状态的封控规则**：
   ```sql
   SELECT id, rule_name, rule_type, rule_value, status 
   FROM waf_block_rules 
   WHERE status = 1 
   AND rule_type IN ('ip_blacklist', 'geo_block');
   ```

2. **创建测试规则**：
   - 规则类型：`ip_blacklist`
   - 规则值：你的测试 IP（如 `192.168.1.100`）
   - 状态：启用

### 4.3 检查生成的配置文件

1. **查看代理配置文件**：
   ```bash
   cat /data/OPENRESTY_WAF/conf.d/vhost_conf/http_https/proxy_http_*.conf
   ```

2. **确认包含封控检查**：
   - 应该包含 `access_by_lua_block` 块
   - 应该调用 `require("waf.ip_block").check_multiple(rule_ids)`

### 4.4 测试封控

1. **使用测试 IP 访问代理**：
   ```bash
   curl -H "X-Forwarded-For: 192.168.1.100" http://your-proxy-domain/test
   ```

2. **查看 Nginx 错误日志**：
   ```bash
   tail -f /var/log/nginx/error.log | grep -i block
   ```

3. **查看封控日志表**：
   ```sql
   SELECT * FROM waf_block_logs ORDER BY id DESC LIMIT 10;
   ```

4. **查看本地备份文件**：
   ```bash
   cat /data/OPENRESTY_WAF/logs/block_*.log
   ```

### 4.5 检查 MySQL 连接

1. **测试 MySQL 连接**：
   ```bash
   mysql -h your-mysql-host -u your-user -p your-database
   ```

2. **查看 MySQL 连接日志**：
   - 检查 Nginx 错误日志中的 MySQL 连接错误
   - 确认 MySQL 服务正常运行
   - 确认网络连通性（防火墙、安全组等）

## 五、常见问题

### 5.1 为什么管理端（waf.conf）没有封控检查？

**原因**：管理端通常不需要封控，只需要系统访问白名单检查。

**解决方案**：如果需要为管理端添加封控，可以取消注释 `waf.conf` 中的封控检查代码。

### 5.2 为什么代理没有封控检查？

**原因**：代理没有关联防护规则（`ip_rule_ids` 为空）。

**解决方案**：在代理管理页面，为代理添加防护规则。

### 5.3 为什么封控日志写入失败？

**原因**：MySQL 连接失败（网络问题、防火墙、安全组等）。

**解决方案**：
- 修复 MySQL 连接问题
- 日志会通过重试机制自动重试
- 如果持续失败，会写入本地备份文件

### 5.4 如何查看本地备份的封控日志？

**位置**：`/data/OPENRESTY_WAF/logs/block_YYYYMMDD.log`

**格式**：JSON 格式，每行一条日志

**恢复方法**：可以编写脚本，将本地备份文件中的日志重新导入数据库。

## 六、代码文件说明

### 6.1 核心文件

- **`lua/waf/ip_block.lua`**：IP 封控核心逻辑
  - `check()`：HTTP/HTTPS 代理封控检查
  - `check_stream()`：TCP/UDP 代理封控检查
  - `check_multiple()`：检查多个规则 ID
  - `log_block()`：记录封控日志

- **`lua/waf/log_queue.lua`**：日志队列机制
  - `write_block_log()`：写入封控日志
  - `retry_write()`：重试写入日志
  - `process_retry_queue()`：处理重试队列

- **`lua/waf/init.lua`**：初始化定时器
  - 每 5 秒处理一次重试队列

- **`lua/waf/nginx_config_generator.lua`**：生成代理配置文件
  - 为关联了防护规则的代理添加封控检查代码

### 6.2 配置文件

- **`conf.d/vhost_conf/waf.conf`**：管理端配置（封控检查被注释）
- **`conf.d/vhost_conf/http_https/proxy_http_*.conf`**：HTTP/HTTPS 代理配置（包含封控检查）
- **`conf.d/vhost_conf/tcp_udp/proxy_*.conf`**：TCP/UDP 代理配置（包含封控检查）

## 七、总结

封控日志为空的主要原因：
1. **代理没有关联防护规则**（最常见）
2. **没有启用状态的封控规则**
3. **规则没有匹配客户端 IP**
4. **MySQL 连接失败导致日志写入失败**（已通过重试机制改进）

**改进措施**：
- 使用 `log_queue.retry_write` 机制，确保日志不丢失
- 支持自动重试和本地备份
- 即使 MySQL 暂时不可用，日志也会写入本地备份文件

**下一步操作**：
1. 检查代理是否关联了防护规则
2. 创建测试规则，直接封控测试 IP
3. 测试封控功能，查看日志是否正常写入
4. 如果 MySQL 连接有问题，检查本地备份文件

