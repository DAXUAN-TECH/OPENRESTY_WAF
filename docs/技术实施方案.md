# OpenResty + MySQL IP 采集与封控系统 - 技术实施方案

## 一、系统架构设计

### 1.1 整体架构

```
┌─────────────┐
│   客户端     │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────┐
│         OpenResty 服务器              │
│  ┌───────────────────────────────┐  │
│  │   access_by_lua (封控检查)    │  │
│  └──────────────┬────────────────┘  │
│                 │                    │
│  ┌──────────────▼────────────────┐  │
│  │   后端应用处理                 │  │
│  └──────────────┬────────────────┘  │
│                 │                    │
│  ┌──────────────▼────────────────┐  │
│  │   log_by_lua (日志采集)       │  │
│  └──────────────┬────────────────┘  │
└─────────────────┼───────────────────┘
                  │
        ┌─────────┴─────────┐
        │                   │
        ▼                   ▼
   ┌─────────┐        ┌─────────┐
   │  MySQL  │        │  Redis  │
   │  数据库  │        │  缓存   │
   └─────────┘        └─────────┘
```

### 1.2 核心组件

1. **OpenResty**：Web 服务器和 Lua 执行环境
2. **MySQL**：数据持久化存储
3. **Redis**：缓存层（可选，提升性能）
4. **Lua 模块**：
   - `lua-resty-mysql`：MySQL 连接
   - `lua-resty-redis`：Redis 连接（可选）
   - `lua-resty-lrucache`：本地缓存

## 二、技术选型

### 2.1 OpenResty 版本
- **推荐版本**：OpenResty 1.21.4.1 或更高
- **Lua 版本**：LuaJIT 2.1

### 2.2 MySQL 版本
- **推荐版本**：MySQL 8.0 或 MariaDB 10.6+
- **字符集**：utf8mb4
- **存储引擎**：InnoDB

### 2.3 依赖模块
```bash
# 安装 lua-resty-mysql
opm get openresty/lua-resty-mysql

# 安装 lua-resty-redis（可选）
opm get openresty/lua-resty-redis

# lua-resty-lrucache 已内置在 OpenResty 中
```

## 三、数据库设计

### 3.1 表结构设计

详见 `init_file/数据库设计.sql`

### 3.2 索引设计
- `waf_access_logs.client_ip`：索引，支持按 IP 查询
- `waf_access_logs.request_time`：索引，支持时间范围查询
- `waf_block_rules.status`：索引，只查询启用规则
- `waf_block_rules.rule_type`：索引，按类型查询

## 四、实现方案

### 4.1 IP 采集实现

#### 4.1.1 采集时机
使用 `log_by_lua` 阶段，在请求处理完成后记录日志，不阻塞请求。

#### 4.1.2 实现流程
1. 获取客户端真实 IP（处理 X-Forwarded-For）
2. 获取请求信息（路径、方法、状态码等）
3. 异步批量写入 MySQL
4. 使用定时器批量提交，提高性能

#### 4.1.3 性能优化
- 使用连接池复用数据库连接
- 批量写入（每 100 条或 1 秒触发一次）
- 失败重试机制

### 4.2 IP 封控实现

#### 4.2.1 封控时机
使用 `access_by_lua` 阶段，在请求处理前进行检查。

#### 4.2.2 实现流程
1. 获取客户端真实 IP
2. 检查白名单（优先级最高）
3. 检查封控规则（单个 IP → IP 段 → 地域）
4. 如果匹配，返回 403，记录封控日志
5. 如果不匹配，继续处理请求

#### 4.2.3 性能优化
- 使用 LRU 缓存缓存规则（本地）
- 使用 Redis 缓存规则（分布式）
- IP 段匹配使用整数比较，避免字符串匹配
- 规则按优先级排序，优先匹配高优先级规则

### 4.3 IP 段匹配算法

#### 4.3.1 CIDR 匹配
```lua
-- IP 转整数
function ip_to_int(ip)
    local a, b, c, d = ip:match("(%d+)%.(%d+)%.(%d+)%.(%d+)")
    return a * 256^3 + b * 256^2 + c * 256 + d
end

-- 检查 IP 是否在 CIDR 范围内
function match_cidr(ip, cidr)
    local ip_int = ip_to_int(ip)
    local base_ip, mask = cidr:match("([^/]+)/(%d+)")
    local base_int = ip_to_int(base_ip)
    local mask_int = bit.lshift(0xFFFFFFFF, 32 - tonumber(mask))
    return bit.band(ip_int, mask_int) == bit.band(base_int, mask_int)
end
```

#### 4.3.2 IP 范围匹配
```lua
function match_ip_range(ip, start_ip, end_ip)
    local ip_int = ip_to_int(ip)
    local start_int = ip_to_int(start_ip)
    local end_int = ip_to_int(end_ip)
    return ip_int >= start_int and ip_int <= end_int
end
```

### 4.4 地域识别实现

#### 4.4.1 方案选择
- **方案一**：使用 GeoIP2 数据库（MaxMind）
- **方案二**：使用第三方 API（ipip.net, ip-api.com）
- **方案三**：自建 IP 库（定期更新）

#### 4.4.2 推荐方案
使用 GeoIP2 数据库，本地查询，性能好。

#### 4.4.3 实现步骤
1. 下载 GeoIP2 数据库文件
2. 使用 `lua-resty-maxminddb` 模块查询
3. 缓存查询结果（LRU 缓存）

## 五、部署方案

### 5.1 目录结构
```
/usr/local/openresty/
├── nginx/
│   ├── conf/
│   │   ├── init_file/          # 初始配置文件目录
│   │   │   ├── nginx.conf      # 主配置文件
│   │   │   └── 数据库设计.sql # 数据库表结构
│   │   └── waf.conf            # WAF 配置
│   └── lua/
│       ├── waf/
│       │   ├── init.lua        # 初始化
│       │   ├── ip_block.lua    # IP 封控
│       │   ├── log_collect.lua # 日志采集
│       │   ├── ip_utils.lua    # IP 工具函数
│       │   └── mysql_pool.lua  # MySQL 连接池
│       └── config.lua          # 配置文件
```

### 5.2 配置文件

详见 `init_file/nginx.conf` 和 `conf.d/set_conf/waf.conf`

### 5.3 启动脚本
```bash
#!/bin/bash
# 启动 OpenResty
/usr/local/openresty/bin/openresty -t && /usr/local/openresty/bin/openresty

# 检查状态
/usr/local/openresty/bin/openresty -s reload
```

## 六、监控与运维

### 6.1 监控指标
- **性能指标**：QPS、响应时间、错误率
- **业务指标**：封控次数、日志采集量
- **系统指标**：CPU、内存、连接数

### 6.2 日志管理
- **访问日志**：Nginx access.log
- **错误日志**：Nginx error.log
- **业务日志**：Lua 脚本日志
- **日志轮转**：使用 logrotate

### 6.3 告警机制
- 数据库连接失败告警
- 封控规则异常告警
- 系统资源告警

## 七、安全考虑

### 7.1 数据安全
- 数据库连接使用 SSL
- 敏感信息加密存储
- 定期备份数据

### 7.2 访问安全
- 管理接口需要认证
- 限制管理接口访问 IP
- 使用 HTTPS

### 7.3 防攻击
- 防止 SQL 注入（使用参数化查询）
- 防止规则配置错误导致误封
- 白名单机制防止误封

## 八、性能优化建议

### 8.1 数据库优化
- 使用连接池，避免频繁建连
- 批量写入，减少数据库操作
- 定期归档历史日志
- 合理使用索引

### 8.2 缓存优化
- 本地 LRU 缓存（热点数据）
- Redis 分布式缓存（规则数据）
- 缓存失效策略（TTL + 主动刷新）

### 8.3 代码优化
- 避免在热路径中使用阻塞操作
- 使用协程处理异步任务
- 减少字符串操作和内存分配

## 九、测试方案

### 9.1 功能测试
- 单元测试：Lua 函数测试
- 集成测试：端到端功能测试
- 压力测试：高并发场景测试

### 9.2 性能测试
- 使用 wrk 或 ab 进行压力测试
- 测试不同规则数量下的性能
- 测试缓存命中率

### 9.3 稳定性测试
- 长时间运行测试
- 异常场景测试（数据库故障、网络中断）

## 十、实施步骤

### 阶段一：基础功能（1-2 周）
1. 搭建 OpenResty 环境
2. 创建数据库表结构
3. 实现 IP 采集功能
4. 实现单个 IP 封控功能

### 阶段二：扩展功能（1-2 周）
1. 实现 IP 段封控
2. 实现地域封控
3. 实现白名单功能
4. 性能优化（缓存、异步）

### 阶段三：管理功能（1 周）
1. 开发管理接口
2. 规则管理功能
3. 日志查询功能

### 阶段四：测试与优化（1 周）
1. 功能测试
2. 性能测试
3. 稳定性测试
4. 优化调整

